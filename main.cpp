#include "ace/SOCK_Connector.h"
#include "ace/Log_Msg.h"

enum
{ 
  AUTH_LAYER_VERSION    = 0x01,
  VER_BIT_LENGTH        = 5,
  VER_BIT_MASK          = 0x1f,
  NEGOTIATION_MODE_MASK = 0x03,
  RESTART               = 0x01,
  AUTHENTICATE          = 0x00,
  RESTART_BYTE          = (AUTH_LAYER_VERSION << (8-VER_BIT_LENGTH)) + RESTART,
  AUTHENTICATE_BYTE     = (AUTH_LAYER_VERSION << (8-VER_BIT_LENGTH)) + AUTHENTICATE,
  SILENT_BOB_BYTE       = 0xfb,
  SILENT_BOB_HANGUP     = 0xfc
};

unsigned byte P [] = {
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC9, 0x0F, 0xDA, 0xA2,
  0x21, 0x68, 0xC2, 0x34, 0xC4, 0xC6, 0x62, 0x8B, 0x80, 0xDC, 0x1C, 0xD1,
  0x29, 0x02, 0x4E, 0x08, 0x8A, 0x67, 0xCC, 0x74, 0x02, 0x0B, 0xBE, 0xA6,
  0x3B, 0x13, 0x9B, 0x22, 0x51, 0x4A, 0x08, 0x79, 0x8E, 0x34, 0x04, 0xDD,
  0xEF, 0x95, 0x19, 0xB3, 0xCD, 0x3A, 0x43, 0x1B, 0x30, 0x2B, 0x0A, 0x6D,
  0xF2, 0x5F, 0x14, 0x37, 0x4F, 0xE1, 0x35, 0x6D, 0x6D, 0x51, 0xC2, 0x45,
  0xE4, 0x85, 0xB5, 0x76, 0x62, 0x5E, 0x7E, 0xC6, 0xF4, 0x4C, 0x42, 0xE9,
  0xA6, 0x37, 0xED, 0x6B, 0x0B, 0xFF, 0x5C, 0xB6, 0xF4, 0x06, 0xB7, 0xED,
  0xEE, 0x38, 0x6B, 0xFB, 0x5A, 0x89, 0x9F, 0xA5, 0xAE, 0x9F, 0x24, 0x11,
  0x7C, 0x4B, 0x1F, 0xE6, 0x49, 0x28, 0x66, 0x51, 0xEC, 0xE6, 0x53, 0x81,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
};

unsigned byte G [] = { 0x02 };

unsigned byte dsa_p[] = {
  0xcb, 0x0a, 0x78, 0x2c, 0x7a, 0xbf, 0xf4, 0x92, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x02, 0x3d, 0x66, 0x28, 0x54, 0xa1, 0x0e, 0x52,
  0xde, 0x49, 0xda, 0x38, 0x3d, 0x9e, 0xe2, 0x1d, 0x7a, 0x33, 0x72, 0x13,
  0xd2, 0x4e, 0xd0, 0x96, 0xf9, 0x5a, 0x5d, 0x37, 0xb8, 0x53, 0x7b, 0xba,
  0xa5, 0x8a, 0x2a, 0x6b, 0x26, 0xbd, 0x32, 0x8f, 0x6a, 0x32, 0xce, 0xc7,
  0x71, 0x80, 0xf7, 0x8d, 0x5b, 0xe4, 0x3d, 0x80, 0xe8, 0x13, 0xe4, 0x01,
  0x8d, 0x09, 0xda, 0x38, 0xbd, 0x58, 0xfd, 0x61, 0x5c, 0x01, 0xfb, 0xab,
  0x49, 0x2e, 0xc2, 0x03, 0xc6, 0x9e, 0x3d, 0xa9, 0xfd, 0x68, 0x2c, 0xe8,
  0xaa, 0x98, 0xf1, 0x5a, 0xd8, 0x05, 0x79, 0x70, 0xed, 0xb4, 0x4f, 0xe1,
  0xed, 0x08, 0xe0, 0x46, 0x2e, 0x5b, 0x8d, 0x97
};

unsigned byte dsa_q[] = {
  0xef, 0x1f, 0x7a, 0x7a, 0x73, 0x36, 0x2e, 0x52, 0x65, 0x15, 0xf3, 0x48,
  0x07, 0x5a, 0xee, 0x26, 0x5e, 0x9e, 0xff, 0x45
};

unsigned byte dsa_g[] = {
  0x93, 0x01, 0x68, 0xde, 0x21, 0xe7, 0xfb, 0x66, 0xc0, 0x37, 0x5e, 0x08,
  0xe9, 0x64, 0x25, 0x5a, 0x0f, 0x7f, 0x0a, 0xd5, 0x45, 0x07, 0xa5, 0x18,
  0x64, 0xaf, 0xdc, 0x68, 0x6f, 0x36, 0xbe, 0x8b, 0xb8, 0xb7, 0x86, 0x54,
  0x08, 0x11, 0x60, 0x60, 0xc5, 0xf3, 0x4f, 0x94, 0xb5, 0x14, 0x6c, 0xbe,
  0xf9, 0xe4, 0xad, 0xb7, 0x03, 0x24, 0xfb, 0xa0, 0x1d, 0x34, 0xc1, 0xc6,
  0x08, 0x17, 0xcb, 0xad, 0xf6, 0x85, 0x4d, 0x65, 0x41, 0x76, 0xcb, 0x39,
  0x1d, 0xe0, 0xd4, 0x1e, 0x0f, 0x0f, 0xbb, 0xc8, 0xce, 0xea, 0x55, 0x46,
  0xc0, 0x9a, 0x67, 0x6b, 0x0d, 0x9a, 0x99, 0x88, 0xc7, 0xa1, 0xce, 0x36,
  0xce, 0x31, 0x59, 0x60, 0x37, 0xa1, 0x8b, 0x4d, 0x54, 0x03, 0x74, 0xbd,
  0xf2, 0xad, 0x07, 0x1a, 0x3f, 0x8d, 0xd1, 0x01, 0x5a, 0x9d, 0x8b, 0xa0,
  0xf0, 0xd5, 0x1c, 0xde, 0x21, 0x2d, 0xb6, 0xda
};

int main(int argc, char *argv[])
{
  const char *server_host = "127.0.0.1";
  u_short server_port = 43518;
  int max_iterations = 4;

  Client server;

  if (connector.connect(server, addr) == -1)
    ACE_ERROR_RETURN ((LM_ERROR,"%p\n","open"),-1);

  ACE_SOCK_Connector connector;

  ACE_INET_Addr addr(server_port, server_host);

  
  BufferedSocketOut bout(server);
  stringbuf & strbuf = *bout.rdbuf();
  FileSink fs(bout);

  strbuf.put(AUTHENTICATE_BYTE);

  Integer g(G, sizeof(G));
  Integer p(P, sizeof(P));

  DH dh(p, g);
  AutoSeededRandomPool rgen;

  Integer R(rgen, 32);
  Integer Ca = a_exp_b_mod_c(g, R, p);

  BigInteger Cb;
  BigInteger Z;
  BigInteger M;
  
  Ca.OpenPGPEncode(fs);
  
  byte k[16];
  
  Integer DLESCa[] = asymCipher.encrypt(bob, Ca, Core.randSource);
  Util.writeMPI(DLESCa[0], rawOut);
  Util.writeMPI(DLESCa[1], rawOut);
  Util.writeMPI(DLESCa[2], rawOut);
  
  rawOut.flush();
  
  if (SILENT_BOB_BYTE != rawIn.read())
      throw new NegotiationFailedException(
          conn.getPeerAddress(),
          "Bob was not silent in the way that we like"
      );
  
  Cb = Util.readMPI(rawIn);
  Core.logger.log(this, "Read first MPI from peer", Core.logger.DEBUG);

  Z = Cb.modPow(R, DiffieHellman.getGroup().getP());
  byte[] kent = Util.MPIbytes(Z);
  Util.makeKey(kent, k, 0, k.length);

  
  
  
  
  BlockCipher c = new Rijndael();
  c.initialize(k);            
  
  PCFBMode pcfb = new PCFBMode(c);
  pcfb.writeIV(Core.randSource, rawOut);
  setOutputStream(pcfb, rawOut);
  setInputStream(c, rawIn);
  //System.err.println("LALA " + pubMe.toString());
  pubMe.writeForWire(out);
  SHA1 ctx = new SHA1();
  byte[] Cabytes = Util.MPIbytes(Ca);
  byte[] Cbbytes = Util.MPIbytes(Cb);
  byte[] Yabytes = pubMe.asBytes();
  ctx.update(Yabytes, 0, Yabytes.length);
  ctx.update(Cabytes, 0, Cabytes.length);
  ctx.update(Cbbytes, 0, Cbbytes.length);
  M = Util.byteArrayToMPI(ctx.digest());
  
  DSASignature sigYaCaCb = DSA.sign(pubMe.getGroup(), privMe, M, 
                                    Core.randSource);            
  sigYaCaCb.write(out);
  out.flush();
  
  DSASignature sigCaCb = DSASignature.read(in);
  
  ctx.update(Cabytes, 0, Cabytes.length);
  ctx.update(Cbbytes, 0, Cbbytes.length);
  M = Util.byteArrayToMPI(ctx.digest());
  if (!DSA.verify(bob, sigCaCb, M)) {
      throw new AuthenticationFailedException(conn.getPeerAddress(),
          "Remote is not who she claims to be, or did not receive the correct DH parameters");
  }
  
  linkInfo = (FnpLinkToken) linkManager.addLink(bob, pubMe, k);
  
  conn.notifyAll();
  ready = true;

  if (server.close () == -1)
    ACE_ERROR_RETURN ((LM_ERROR, "%p\n", "close"),-1);

  return 0;
}
